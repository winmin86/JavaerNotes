><a href="https://blog.csdn.net/www1575066083/article/details/80367574" target="_blank">[链接]</a>

### 1、原子性：
一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。

### 2、可见性：
当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

### 3、有序性：
程序执行的顺序按照代码的先后顺序执行。\
注意：此处的顺序执行是指程序最终的执行结果跟程序严格按照代码的书写顺序执行的结果是一样的，对应的是指令重排序问题。

### 4、指令重排序：
一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和按代码书写顺序情况下执行得到的结果是一致的【重排序不会影响单个线程内程序执行的结果】。\
处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令A必须用到指令B的结果，那么处理器会保证B会在A之前执行。\
指令重排序不会影响单个线程的执行，但是会影响到多线程并发执行的正确性。\
并发程序正确地执行，必须要保证原子性、可见性以及有序性。

### 5、进程：
进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间，一个进程中可以启动多个线程。比如在Windows系统中，一个运行的exe就是一个进程。\
每个进程对应一定的内存地址空间，并且只能使用它自己的内存空间，各个进程间互不干扰。并且进程保存了程序每个时刻的运行状态，这样就为进程切换提供了可能。\
当进程暂时时，它会保存当前进程的状态（比如进程标识、进程的使用的资源等），在下一次重新切换回来时，便根据之前保存的状态进行恢复，然后继续执行。\
在Java中，一个应用程序对应着一个JVM实例（也有地方称为JVM进程），一般来说名字默认为java.exe或者javaw.exe（windows下可以通过任务管理器查看）。

### 6、线程：
线程是指进程中的一个执行流程，一个进程中可以运行多个线程。比如java.exe进程中可以运行很多线程。线程总是属于某个进程，进程中的多个线程共享进程的内存。
Java采用的是单线程编程模型，即在我们自己的程序中如果没有主动创建线程的话，只会创建一个线程，通常称为主线程。但是要注意，虽然只有一个线程来执行任务，不代表JVM中只有一个线程，JVM实例在创建的时候，同时会创建很多其他的线程（比如守护线程垃圾收集器线程）。

### 7、临界资源（也有称为共享资源）：
被多个线程同时访问的资源。

### 8、互斥访问：
在同一时刻，只能有一个线程访问临界资源，也称作同步互斥访问。

### 9、线程安全：
线程安全：就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问，直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。\
线程不安全：就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。

### 10、死锁：
死锁是两个或更多线程阻塞着等待获取其它处于死锁状态的线程所持有的锁。\
例如，如果线程1锁住了A，然后等待B尝试对B进行加锁，同时线程2已经锁住了B，接着等待A尝试对A进行加锁，这时死锁就发生了。\
线程1永远得不到B，线程2也永远得不到A，并且它们永远也不会知道发生了这样的事情。为了得到彼此的对象（A和B），它们将永远阻塞下去。这种情况就是一个死锁。
>//该情况如下：
Thread 1  locks A, waits for B
Thread 2  locks B, waits for A

出现以下四种情况会产生死锁： 
1. 相互排斥：一个线程或进程永远占有共享资源，比如，独占该资源。 
2. 循环等待：例如，进程A在等待进程B，进程B在等待进程C，而进程C又在等待进程A。 
3. 部分分配：资源被部分分配，例如，进程A和B都需要访问一个文件，同时需要用到打印机，进程A得到了这个文件资源，进程B得到了打印机资源，但两个进程都不能获 得全部的资源了。 
4. 缺少优先权：一个进程获得了该资源但是一直不释放该资源，即使该进程处于阻塞状态。

### 11、线程饥饿现象：
指系统不能保证某个进程的等待时间上界，从而使该进程长时间等待，当等待时间给进程推进和响应带来明显影响时，称发生了进程饥饿。\
当饥饿到一定程度的进程所赋予的任务即使完成也不再具有实际意义时称该进程被饿死。\
资源在其中两个或以上线程或进程相互使用，第三方线程或进程始终得不到。想像一下三个人传球，其中两个人传来传去，第三个人始终得不到。\
一个线程因为 CPU 时间全部被其他线程抢走而得不到 CPU 运行时间，这种状态被称之为“饥饿”。\
避免饿死就应该是采用队列的方式，保证每个人都有机会获得请求的资源。 当然实现方式可以很多个变化，比如优先级，时间片，等，都是“队列”的特殊形式。\
线程饥饿现象出现情况： 
1. 高优先级线程吞噬所有的低优先级线程的 CPU 时间。 
2. 线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。 
3. 线程在等待一个本身(在其上调用 wait())也处于永久等待完成的对象，因为其他线程总是被持续地获得唤醒。

### 12、线程同步与线程异步：`重点在于多个任务和事件发生时，一个事件的发生或执行是否会导致整个流程的暂时等待`
线程同步：如果有多个任务或者事件要发生，这些任务或者事件必须逐个地进行，一个事件或者任务的执行会导致整个流程的暂时等待，这些事件没有办法并发地执行。\
线程异步：如果有多个任务或者事件发生，这些事件可以并发地执行，一个事件或者任务的执行不会导致整个流程的暂时等待。\
举个简单的例子：假如有一个任务包括两个子任务A和B，对于同步来说，当A在执行的过程中，B只有等待，直至A执行完毕，B才能执行；而对于异步就是A和B可以并发地执行，B不必等待A执行完毕之后再执行，这样就不会由于A的执行导致整个任务的暂时等待。

### 13、线程阻塞与线程非阻塞：当发出请求一个操作时，如果条件不满足，是会一直等待还是返回一个标志信息
线程阻塞：当某个事件或者任务在执行过程中，它发出一个请求操作，但是由于该请求操作需要的条件不满足，那么就会一直在那等待，直至条件满足。\
线程非阻塞：某个事件或者任务在执行过程中，它发出一个请求操作，如果该请求操作需要的条件不满足，会立即返回一个标志信息告知条件不满足，不会一直在那等待。\
举个例子：假如我要读取一个文件中的内容，如果此时文件中没有内容可读，对于同步来说就是会一直在那等待，直至文件中有内容可读；而对于非阻塞来说，就会直接返回一个标志信息告知文件中暂时无内容可读。




