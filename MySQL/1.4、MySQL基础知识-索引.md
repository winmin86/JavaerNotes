

```sql

mysql> CREATE TABLE `award` (
    ->    `id` INT(11) NOT NULL AUTO_INCREMENT COMMENT '用户id',
    ->    `aty_id` VARCHAR(100) NOT NULL DEFAULT '' COMMENT '活动场景id',
    ->    `nickname` VARCHAR(12) NOT NULL DEFAULT '' COMMENT '用户昵称',
    ->    `is_awarded` TINYINT(1) NOT NULL DEFAULT 0 COMMENT '用户是否领奖',
    ->    `award_time` INT(11) NOT NULL DEFAULT 0 COMMENT '领奖时间',
    ->    `account` VARCHAR(12) NOT NULL DEFAULT '' COMMENT '帐号',
    ->    `password` CHAR(32) NOT NULL DEFAULT '' COMMENT '密码',
    ->    `message` VARCHAR(255) NOT NULL DEFAULT '' COMMENT '获奖信息',
    ->    `created_time` INT(11) NOT NULL DEFAULT 0 COMMENT '创建时间',
    ->    `updated_time` INT(11) NOT NULL DEFAULT 0 COMMENT '更新时间',
    ->    PRIMARY KEY (`id`)
    ->  ) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT='获奖信息表';
Query OK, 0 rows affected (0.22 sec)
```

**创建索引**\
 创建索引的基本格式是：\
 CREATE INDEX IndexName ON `TableName`(`字段名`(length)) \
 或者\
 ALTER TABLE TableName ADD INDEX IndexName(`字段名`(length))

可以不指定length,不知道则是字段长度。如果是CHAR,VARCHAR,类型,length可以小于字段的实际长度,如果是BLOB和TEXT类型就必须指定长度。

方式一：
```sql
mysql> CREATE INDEX idx_account ON award(account);
Query OK, 0 rows affected (0.19 sec)
Records: 0  Duplicates: 0  Warnings: 0
```
方式二：
```sql
mysql> ALTER TABLE award ADD INDEX idx_account(account);
Query OK, 0 rows affected (0.17 sec)
Records: 0  Duplicates: 0  Warnings: 0
```
**删除索引**
```sql
mysql> DROP INDEX idx_account ON award;
Query OK, 0 rows affected (0.12 sec)
Records: 0  Duplicates: 0  Warnings: 0
```
**查看索引**
```sql
mysql> show index from award;
+-------+------------+-------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| Table | Non_unique | Key_name    | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |
+-------+------------+-------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| award |          0 | PRIMARY     |            1 | id          | A         |           0 |     NULL | NULL   |      | BTREE      |         |               |
| award |          1 | idx_account |            1 | account     | A         |           0 |     NULL | NULL   |      | BTREE      |         |               |
+-------+------------+-------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
2 rows in set (0.00 sec)
```

几个经典的创建索引实例：
```sql
-- 创建唯一索引
-- 唯一索引,与普通索引类似,但是不同的是唯一索引要求所有的类的值是唯一的,这一点和主键索引一样.但是他允许有空值
CREATE UNIQUE INDEX IndexName ON `TableName`(`字段名`(length));

-- 创建组合索引
CREATE INDEX IndexName On `TableName`(`字段名`(length),`字段名`(length),...);

-- 创建全文索引

ALTER TABLE `TableName` ADD FULLTEXT IndexName (`字段名`(length),`字段名`(length),...);
```

---
### 全文索引

以前的MySQL的全文索引只能用在MyISAM表格的char、varchar和text的字段上，不过新版的MySQL5.6.24上InnoDB引擎也加入了全文索引。

```sql

-- MATCH (title,body) 里面的值必须是前面建立全文索引的两个字段不能少。
SELECT * FROM articles WHERE MATCH (title,body)     AGAINST ('+apple -banana' IN BOOLEAN MODE);   -- + 表示AND，即必须包含。- 表示NOT，即不包含。

SELECT * FROM articles WHERE MATCH (title,body)     AGAINST ('apple banana' IN BOOLEAN MODE);   -- apple和banana之间是空格，空格表示OR，即至少包含apple、banana中的一个。

SELECT * FROM articles WHERE MATCH (title,body)     AGAINST ('+apple banana' IN BOOLEAN MODE);   -- 必须包含apple，但是如果同时也包含banana则会获得更高的权重。

SELECT * FROM articles WHERE MATCH (title,body)     AGAINST ('+apple ~banana' IN BOOLEAN MODE);  --  ~ 是我们熟悉的异或运算符。返回的记录必须包含apple，但是如果同时也包含banana会降低权重。但是它没有 +apple -banana 严格，因为后者如果包含banana压根就不返回。

SELECT * FROM articles WHERE MATCH (title,body)     AGAINST ('+apple +(>banana <orange)' IN BOOLEAN MODE);   -- 返回同时包含apple和banana或者同时包含apple和orange的记录。但是同时包含apple和banana的记录的权重高于同时包含apple和orange的记录。

SELECT * FROM articles WHERE MATCH (title,body)     AGAINST ('+ap* ba*' IN BOOLEAN MODE);  -- *通配符，并且只能放在结尾不能放在开头
```
mysql 默认支持全文检索的字符长度是4，可以用SHOW VARIABLES LIKE 'ft_min_word_len' 来查看指定的字符长度，也可以在mysql配置文件my.ini 更改最小字符长度，方法是在my.ini 增加一行 比如：ft_min_word_len = 2，改完后重启mysql即可。  

另外，MySQL还会计算一个词的权值，以决定是否出现在结果集中，具体如下：\
mysql在集和查询中的对每个合适的词都会先计算它们的权重，一个出现在多个文档中的词将有较低的权重(可能甚至有一个零权重)，因为在这个特定的集中，它有较低的语义值。否则，如果词是较少的，它将得到一个较高的权重，mysql默认的阀值是50%，上面‘you’在每个文档都出现，因此是100%，只有低于50%的才会出现在结果集中。

MySQL不支持中文全文索引，原因很简单：与英文不同，中文的文字是连着一起写的，中间没有MySQL能找到分词的地方，截至目前MySQL5.6版本是如此，但是有变通的办法，就是将整句的中文分词，并按urlencode、区位码、base64、拼音等进行编码使之以“字母+数字”的方式存储于数据库中。

